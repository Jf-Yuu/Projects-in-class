# -*- coding: utf-8 -*-
"""Fitter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H3zlHv-EjevcBQ5iqDLnS9G0EkwVJq8A
"""

# Junfei Yu 60345054

import math
import numpy as np
import matplotlib.pyplot as plt


x = np.array([1.0, 1.05, 1.1, 1.15, 1.2, 1.25, 1.3, 1.35, 1.4, 1.45, 1.5, 1.55, 1.6, 1.65, 1.7, 1.75, 1.8, 1.85, 1.9, 1.95, 2.0, 2.05, 2.1, 2.15, 2.2, 2.25,
              2.3, 2.35, 2.4, 2.45, 2.5, 2.55, 2.6, 2.65, 2.7, 2.75, 2.8, 2.85, 2.9, 2.95, 3.0, 3.05, 3.1, 3.15, 3.2, 3.25, 3.3, 3.35, 3.4, 3.45])
y = np.array([3.057, 6.977, 5.741, 8.28, 7.881, 9.671, 10.495, 11.68, 13.033, 12.953, 13.886, 16.982, 15.586, 17.675, 19.693, 21.809, 22.382, 24.753, 25.198,
              28.625, 57.949, 30.381, 34.064, 34.802, 37.991, 40.912, 43.479, 44.152, 49.787, 50.143, 53.739, 54.937, 60.69, 65.016, 66.816, 72.718, 72.823,
              77.263, 81.448, 84.766, 88.736, 92.431, 97.134, 235.871, 106.509, 110.69, 114.552, 118.857, 124.744, 129.943])


def linearize(data):
  """Create a one-dimensional numpy array containing all the log values for inputted data"""
  logList = []
  for i in range(0, len(data)):
    logList.append(math.log(data[i]))
  logData = np.array(logList)
  return logData


def totalErrorCalculator(xdata, ydata, m, b):
  """Calculate the total error for a linear fit of inputted xdata and ydata"""
  xSquareList = xdata**2
  Xsquare = sum(xSquareList) # sum of xi**2 for xi in xdata
  ySquareList = ydata**2
  Ysquare = sum(ySquareList) # sum of yi**2 for yi in ydata
  XYlist = []
  for i in range(len(xdata)):
    XYlist.append(xdata[i]*ydata[i])
  XY = sum(XYlist)
  X = sum(xdata)
  Y = sum(ydata)
  N = len(xdata)

  error = Ysquare + m**2 * Xsquare + N * b**2 - 2*m*XY - 2*b*Y + 2*m*b*X
  return error


def errorCalculator(xval, yval, m, b):
  """Calculate the error of an individual datapoint (x,y)"""
  singleError = (yval - m*xval - b)**2
  return singleError


def linearParameterFinder(xdata, ydata):
  """Calculate the minimum error parameters (best linear fit)"""
  xSquareList = xdata**2
  Xsquare = sum(xSquareList)
  XYlist = []
  for i in range(0, len(xdata)):
    XYlist.append(xdata[i]*ydata[i])
  XY = sum(XYlist)
  X = sum(xdata)
  Y = sum(ydata)
  N = len(xdata)
  m = (N*XY - X*Y) / (N*Xsquare - X**2)
  b = (Y - m*X) / N

  return (m, b)


def mErrorSweep(xdata, ydata, b):
  """Find the error associated with holding parameter b constant and varying the value of parameter m"""
  bErrorList = []
  m = -20
  mList = []
  while m <= 20:
    totalError = totalErrorCalculator(xdata, ydata, m, b)
    bErrorList.append(totalError)
    mList.append(m)
    m += 0.25
  plt.plot(mList, bErrorList)
  plt.title("mErrorSweep Plot (-20≤m≤20)")
  plt.xlabel("m")
  plt.ylabel("Error")
  plt.show()
  return bErrorList


def bErrorSweep(xdata, ydata, m):
  """Find the error associated with holding parameter m constant and varying the value of parameter b"""
  mErrorList = []
  b = -20
  bList = []
  while b <= 20:
    totalError = totalErrorCalculator(xdata, ydata, m, b)
    mErrorList.append(totalError)
    bList.append(b)
    b += 0.25
  plt.plot(bList, mErrorList)
  plt.title("bErrorSweep Plot (-20≤b≤20)")
  plt.xlabel("b")
  plt.ylabel("Error")
  plt.show()
  return mErrorList


def errorContributionFinder(xdata, ydata, m, b):
  """Find the error associated with each datapoint and the fitted line"""
  errorList = []
  for i in range(len(xdata)):
    error = errorCalculator(xdata[i], ydata[i], m, b)
    errorList.append(error)
  errorArray = np.array(errorList)
  return errorArray


def outlierIndexFinder(xdata, ydata, m, b):
  """Identify the indices of datapoints resulting in the greatest error with the linear fit"""
  errors = errorContributionFinder(xdata, ydata, m, b)
  meanError = np.mean(errors)
  stdError = np.std(errors)
  outliers = []
  for i in range(len(errors)):
    if errors[i] > meanError + stdError or errors[i] < meanError - stdError:
      outliers.append(i)
  return outliers


def outlierRemover(xdata, ydata, outliers):
  """Remove outlier values from xdata and ydata indicated by the list outliers"""
  xOutliers = []
  yOutliers = []
  # create lists containing outlier values in xdata and ydata
  for i in outliers:
    xOutliers.append(xdata[i])
    yOutliers.append(ydata[i])
  # remove outliers from x data
  xnew = xdata
  for item in xOutliers:
    xnew = xnew[xnew != item]
  ynew = ydata
  for item in yOutliers:
    ynew = ynew[ynew != item]
  outlierRemovedData = np.vstack((xnew, ynew))
  return outlierRemovedData


def linearFitterAndAnalysis(linearizedX, linearizedY):
  """Return the linear fit parameter values (m, b) as a tuple"""
  m, b = linearParameterFinder(linearizedX, linearizedY)
  mErrorSweep(linearizedX, linearizedY, m)
  bErrorSweep(linearizedX, linearizedY, b)
  return (m, b)


def outlierAnalysis(linearizedX, linearizedY, m, b):
  """Find and remove outliers from linearized data, return processed data"""
  outliers = outlierIndexFinder(linearizedX, linearizedY, m, b)
  outlierRemovedData = outlierRemover(linearizedX, linearizedY, outliers)
  return outlierRemovedData

    
def bigPlotter(oldX, oldY, newX, newY, oldm, oldb, newm, newb):
  """Generate a plot containing old and new data as scatter points, and linear fits of old and new data"""
  
  # Visualize original(old) data as scatter points
  plt.scatter(oldX, oldY, color = "red", s = 35, label = "original data (linearized)")
  # Visualize outlier-removed(new) data as scatter points
  plt.scatter(newX, newY, color = "black", s = 30, label = "outlier-removed data (linearized)")

  # Visualize the linear fit of the old data
  oldXfit = oldX
  oldYfit = oldm * oldXfit + oldb
  plt.plot(oldXfit, oldYfit, color = "orange", linewidth = 3, label = "linear fit of original data")

  # Visualize the linear fit of the new data
  newXfit = newX
  newYfit = newm * newXfit + newb
  plt.plot(newXfit, newYfit, color = "blue", linewidth = 3, label = "linear fit of outlier-removed data")

  plt.title('Data and Linear fits')
  plt.xlabel('x')
  plt.ylabel('y')
  plt.legend()
  plt.show()

        
def main():
  linearizedX = linearize(x)
  linearizedY = linearize(y)
  # find parameters for a linear fit of the linearized data
  oldm, oldb = linearParameterFinder(linearizedX, linearizedY)

  mErrorSweep(linearizedX, linearizedY, oldb)
  bErrorSweep(linearizedX, linearizedY, oldb)

  outlierRemovedData = outlierAnalysis(linearizedX, linearizedY, oldm, oldb)
  # find parameters for a linear fit of the outlier-removed data
  outlierRemovedX = outlierRemovedData[0]
  outlierRemovedY = outlierRemovedData[1]
  newm, newb = linearParameterFinder(outlierRemovedX, outlierRemovedY)

  # generate the final output plot
  bigPlotter(linearizedX, linearizedY, outlierRemovedX, outlierRemovedY, oldm, oldb, newm, newb)



# Don't change this!
if __name__ == "__main__":
    main()