# -*- coding: utf-8 -*-
"""Final project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18hia7WyBv7RrNh66tL4W-v7C3Zj9lGSV
"""

from pandas._libs.tslibs.offsets import Nano
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import scipy.stats as sp
import statsmodels.api as sm

from datetime import datetime


# Data Preparation

NPI_link = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vScdtO1GoLXylXB7rn5jlphipkGA3nDOZq8DtYh3JHoMhch1Lgea8vNdvTBBk0oaL7258LxfuTyG4GB/pub?output=csv'
df1 = pd.read_csv(NPI_link)
df_NPI = df1[['Date', 'Country', 'Measure_L1', 'Measure_L2', 'Measure_L3', 'Measure_L4']]

infection_link = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTAjyrEl2P3Y-WV9nZ-NEiyarshaxyUZbY9lI-70E-DEmBKlVB4cX3yoDmEk9w0lDiiReThd3jKsP3g/pub?output=csv'
df3 = pd.read_csv(infection_link)
df_infec = df3[['Date', 'Country', 'total_cases', 'new_cases', 'total_cases_per_million', 'total_deaths_per_million', 'new_cases_per_million', 'new_deaths_per_million']]


""" Not used in this project, but can be used to expand this project and make more analysis
vaccination_link = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQG0Xt82LesafCKJAAgco-ZqTM-EIIFFQD6tDw-r-fMufNXdl-2zkY85VpSpQfssfpcqXVVtnQF1Bi6/pub?output=csv'
df2 = pd.read_csv(vaccination_link)
df_vac = df2[['Date', 'Country', 'total_vaccinations_per_hundred', 'people_vaccinated_per_hundred', 'people_fully_vaccinated_per_hundred']]
df_vac.head()

country_character_link = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTzo8UfZNCAvf6H_0eM-lSy6zX4lUWvalt6WdtMQoYvv-gW2bN25Quisxn2THDazfNHm6Q8hG_XOYdX/pub?output=csv'
df_character = pd.read_csv(country_character_link)
df_character.head()
"""


def allCountries(dataframe):
  """Returns a list of all countries in the given dataframe without duplicate."""
  countries = dataframe['Country'].unique().tolist()
  return countries


def allMeasures(dataframe):
  """ Returns a list of all measures in the given dataframe without duplicate."""
  measures = pd.unique(dataframe[['Measure_L1', 'Measure_L2', 'Measure_L3', 'Measure_L4']].values.ravel())
  return measures


def findTopMeasures(dataframe, n):
  """Find the most commonly implemented measures by all countries"""
  measures = pd.concat([dataframe['Measure_L1'], dataframe['Measure_L2'], dataframe['Measure_L3'], dataframe['Measure_L4']])
  counts = measures.value_counts()
  top = counts.head(n).index.tolist()
  return top


# Rearrange original NPI data

def startDateFinder(dataframe, country, colName):
  '''Find the date on which data change from 0 to a positive number, can be used to find the date of outbreak of the pandemic or when a policy is implemented'''
  CountryDf = dataframe[dataframe['Country'].str.strip() == country.strip()]

  filtered = CountryDf.loc[CountryDf[colName] > 0]

  if len(filtered) > 0:
    startIndex = filtered.index[0]
    return dataframe.loc[startIndex, 'Date']
  else:
    return '2020/1/5' # The date that WHO conducted risk communication


def countryPolicyExtract(dataframe, country, policyList):
  """Select data of the specified country and policies in policyList, and return a new dateframe with certain policies and their issurance dates of that country"""
  CountryDf = dataframe[dataframe['Country'].str.strip() == country.strip()]
  startDate = startDateFinder(df_infec, country, 'new_cases')

  # Get the dates and policy names for all policies included in the policy list
  policyDates = []
  for policy in policyList:
    policyData = CountryDf.loc[CountryDf.isin([policy]).any(axis=1), ['Date', 'Measure_L1', 'Measure_L2', 'Measure_L3', 'Measure_L4']].values.tolist()
    if len(policyData) == 0: # the country didnn't implement the policy
      policyData = [[str(startDate), policy]] # set it at startDate so that we get 0 when calculating intervals
    policyDates.extend(policyData)
  
  # Remove duplicates and keep only the earliest date when a policy was implemented
  uniquePolicyDates = []
  for value in policyDates:
    date, policy = value[0], value[1:]
    try:
      date = datetime.strptime(date, '%Y/%m/%d')
    except ValueError:
      continue
    for i in range(len(policy)):
      if policy[i] in policyList:
        uniquePolicyDates.append([date, policy[i]])
  
  # Sort the uniquePolicyDates by dates
  uniquePolicyDates = sorted(uniquePolicyDates, key = lambda x: x[0])

  # Create the result DataFrame
  resultDf = pd.DataFrame(uniquePolicyDates, columns=['Date', 'Measures'])
  resultDf.drop_duplicates(subset = 'Measures', keep = 'first', inplace = True)
  resultDf.reset_index(drop = True)
  rows = resultDf['Measures'].isin(policyList)
    
  return resultDf.loc[rows].reset_index(drop = True)


def actualPolicies(dataframe, country, policyList):
  """Find the policies in the policyList that were actuallly implemented by certain country, so that we can use only these policies in further regression"""
  CountryDf = dataframe[dataframe['Country'].str.strip() == country.strip()]
  actualPolicy = []
  for policy in policyList:
    policyData = CountryDf.loc[CountryDf.isin([policy]).any(axis=1), ['Date', 'Measure_L1', 'Measure_L2', 'Measure_L3', 'Measure_L4']].values.tolist()
    if len(policyData) != 0: # the country actually implemented the policy
      actualPolicy.append(policy)
  return actualPolicy


def convertDates(dataframe, date_col):
  """Converts a time series dataframe with a date column in the format '2020/1/4' to a new dataframe with a datetime index that can be used for further analysis and plotting. """
  newdf = dataframe.copy()  # create a copy of the input dataframe
  newdf[date_col] = pd.to_datetime(newdf[date_col], format='%Y/%m/%d', errors = 'coerce')
  dataframe[date_col] = pd.to_datetime(dataframe[date_col], format = '%Y/%m/%d', errors = 'coerce')
  newdf.set_index(date_col, inplace = True)
  return newdf, dataframe  # return a new DataFrame with datetime index and the original DataFrame (values in the date column change from str to pandas.datetim).


def fillDateGaps(dataframe, startDate, endDate):
  """Add missing dates to a dataframe and fills the measures column with NaN values if no measure is provided on that specific date."""
  
  # Create a new dataframe with dates from startDate to endDate
  dateRange = pd.date_range(start = startDate, end = endDate)
  newDf = pd.DataFrame({'Date': dateRange})

  # Merge the new dataframe with the input dataframe on date column, fill gaps with NaNs
  mergedDf = pd.merge(newDf, dataframe, on = 'Date', how = 'outer')

  # Sort the dataframe by date
  mergedDf.sort_values(by = 'Date', inplace = True)

  # Replace NaNs in measures column with empty strings
  mergedDf['Measures'] = mergedDf['Measures'].fillna('')

  # Exclude rows in the dataframe whose date is not in the dateRange
  dateRangeStr = [d.strftime('%Y/%m/%d') for d in dateRange]
  mergedDf = mergedDf[mergedDf['Date'].isin(dateRangeStr)]

  return mergedDf


def intervalCalculator(NPIdata, infectionData, NPI, country):  # NPIdata should be in the same form as the output dataframe of function "countryPolicyExtract()"
  """Calculate the number of days between the covid outbreak date and the date on which the country implemented the NPI."""

  # Find the covid pandemic outbreak date of  by finding the first date of new cases in this country in the infection dataframe
  covidOutbreak = startDateFinder(infectionData, country, 'new_cases')
  
  # Find the date on which the country implemented certain NPI
  row = NPIdata[NPIdata['Measures'] == NPI].index

  if len(row) == 0: # which means certain country did not implement the NPI
    return None
  
  NPIdate = NPIdata.loc[row[0], 'Date']

  if isinstance(NPIdate, str):
    NPIdate = datetime.strptime(NPIdate, '%Y/%m/%d')
  if isinstance(covidOutbreak, str):
    covidOutbreak = datetime.strptime(covidOutbreak, '%Y/%m/%d')
  
  return int((NPIdate - covidOutbreak).days)


def createIntervalDf(originalNPIdata, infectiondata, NPIList): 
  # originalNPIdata: the dataframe with raw data(df_NPI), NPIList is a list of NPIs that the user wants to take into consideration
  """Generate a dataframe with countries as column indices and NPIs as row indices, with values indicating the time interval between the outbreak of covid19 and the implementation of the NPI for each country."""
  
  countryList = allCountries(originalNPIdata)

  # Generate the interval dataframe with countries as column indexes and measures as row indexes
  intervalDf = pd.DataFrame(index = NPIList, columns = countryList)

  for country in countryList:
    countryNPI = countryPolicyExtract(originalNPIdata, country, NPIList)
    dateIndexedNPI, NPIdf = convertDates(countryNPI, 'Date')
    for npi in NPIList:
      interval = intervalCalculator(NPIdf, infectiondata, npi, country)
      intervalDf.loc[npi, country] = interval
  return intervalDf


# Data Analysis - summarize

def summarizeData (dataframe, argName):
  '''Calculate summary statistics for specified column (argName) of the inputted dataframe'''
  dataCol = dataframe[argName].astype(int)
  n, minmax, dataMean, dataVariance, skewness, kurtosis = sp.stats.describe(dataCol)
  dataMin, dataMax = minmax
  percentile25 = dataCol.quantile(0.25)
  percentile50 = dataCol.quantile(0.5)
  percentile75 = dataCol.quantile(0.75)
  statsList = [n, dataMin, dataMax, dataMean, dataVariance, percentile25, percentile50, percentile75]
  return statsList


def weekInfectionExtract(InfectionData, country, colName):
  """Extract weekly average infection data for a given country and column (colName should be in df_infec)."""

  # Filter the DataFrame to only include data for the given country
  CountryDf = InfectionData[InfectionData['Country'].str.strip() == country.strip()]
  CountryDf = CountryDf.reset_index()

  weekAverages = {}
  # Loop over each week of data and calculate the average for the given column
  for i in range(1, len(CountryDf) // 7):
    startDate = CountryDf.loc[7 * (i-1), 'Date']
    endDate = CountryDf.loc[7 * i, 'Date']
    weekAverage = np.nansum(CountryDf[(CountryDf['Date'] >= startDate) & (CountryDf['Date'] < endDate)][colName]) / 7
    if 'Week' not in weekAverages:
      weekAverages['Week'] = []
    weekAverages['Week'].append(i)
    if 'Weekly Average' not in weekAverages:
      weekAverages['Weekly Average'] = []
    weekAverages['Weekly Average'].append(weekAverage)
  
  weeklyAverageDf = pd.DataFrame(weekAverages)
  weeklyAverageDf = weeklyAverageDf.apply(lambda x: x.astype(float))
  
  return weeklyAverageDf


# Data visualization

def makeHeatmap(dataframe):
  '''Find and generate a heatmap based on Kendall correlation coefficient between the columns of the input dataframe'''

  dataframe.dropna(axis = 1, how = 'any', inplace = True)

  colNum = dataframe.shape[1]
  Kendall = dataframe.corr(method = 'kendall')

  fig = plt.figure(figsize=(10, 8), dpi = 120)
  plt.imshow(Kendall, cmap = 'coolwarm')
  plt.colorbar()
  plt.title('Heatmap of Kendall correlation coefficients between intervals')
  labelList = dataframe.columns.tolist()
  plt.xticks(np.arange(colNum), labelList, fontsize = 5, rotation = 270)
  plt.yticks(np.arange(colNum), labelList, fontsize = 5)
  plt.show()


def infectionTrend(infectionDf, ycol):
  """Plot all trend lines for different countries in one plot, the trend of which is decided by ycol (e.g. new_cases, total_cases)"""

  fig, ax = plt.subplots()

  countryList = allCountries(infectionDf)
  for country in countryList:
    averageDf = weekInfectionExtract(infectionDf, country, ycol)
    if averageDf.empty:
      averageDf = pd.DataFrame({'Week': [], 'Weekly Average': []})
    ax.plot(averageDf['Week'], averageDf['Weekly Average'], label = country)

  ax.set_xlabel('week')
  ax.set_ylabel(ycol)
  ax.set_title(f'Weekly Average data worldwide ({ycol})')
  plt.show()


# Regression - Create binary dummy variables → run regression

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

def createDummyVariables(NPIdata, country, NPIList):
  """Creates binary dummy variables for each NPI measure in the NPIList based on NPIdata."""

  # Extract the NPI measures that were actually implemented by specified country
  actualNPIs = actualPolicies(df_NPI, country, NPIList)

  for npi in actualNPIs:
    colName = 'dummy_ ' + npi
    NPIdata.loc[:, colName] = 0

    # Locate the row where the npi measure is implemented
    row = NPIdata[NPIdata['Measures'] == npi].index

    # Set all rows after the row where the condition is met to 1
    if len(row) > 0:
      NPIdata.loc[row[0]:, colName] = 1
        
  return NPIdata # dataframe with additional dummy variables for each NPI



def createXdata(dataframe, colNames):
  """Create X data for regression from columns of a DataFrame (NPI)"""
  if len(colNames) > 1:
    # Stack the columns horizontally if more than one column name is provided
    Xdata = np.column_stack([dataframe[colName].values for colName in colNames])
  elif len(colNames) == 1:
    # Use the single column as X data if only one column name is provided
    Xdata = dataframe[colNames]
  
  Xdf = pd.DataFrame(Xdata, columns = colNames)
  
  # Concatenate the X DataFrame with the 'Date' column
  X = pd.concat([dataframe['Date'], Xdf], axis=1)

  # Add the date of NPI implementation by 14 days (assume it is the date that the NPI began to take effect)
  # X['Date'] = X['Date'] + pd.Timedelta(days=14)
  
  return X


def createYdata(dataframe, country, colName):
  """Create y data for regression from columns of a DataFrame (infections and deaths)"""
  CountryDf = dataframe[dataframe['Country'].str.strip() == country.strip()]
  ydata = pd.DataFrame(CountryDf[['Date', colName]], columns = ['Date', colName])
  return ydata


from statsmodels.tsa.seasonal import seasonal_decompose

def deseasonalize(y, yName):
  """Perform deseasonalization on time series data y and remove seasonal component"""

  # Convert dates in Date column from string to datetime format and set as index
  y['Date'] = pd.to_datetime(y['Date'], format='%Y/%m/%d', errors = 'coerce')
  y = y.set_index('Date')['new_cases_per_million'].fillna(0)

  # Decompose time series into trend, seasonal and residual components
  decompose_result = seasonal_decompose(y, model = 'additive')

  trend = decompose_result.trend
  seasonal = decompose_result.seasonal
  residual = decompose_result.resid

  trendDf = trendDf = pd.DataFrame({'Date': y.index, yName: trend})

  return trendDf


def yTrendPlot(y):
  """Decompose time series data y into trend, seasonal and residual components and plot."""
  decompose_result = seasonal_decompose(y, model = 'additive')
  decompose_result.plot()


def mergeDataframe(df1, df2):
  """Merge two dataframes based on the 'Date' column and return a new dataframe with all columns from both dataframes."""

  df1['Date'] = pd.to_datetime(df1['Date']).dt.strftime('%Y-%m-%d')
  df2['Date'] = pd.to_datetime(df2['Date']).dt.strftime('%Y-%m-%d')

  # Determine which dataframe is smaller
  if len(df1) > len(df2):
    smallDf, largeDf = df2, df1
  else:
    smallDf, largeDf = df1, df2

  newDf = smallDf.copy()

  for idx, row in smallDf.iterrows():
    dateVal = row['Date']
  
    # Find the matching row in the large dataframe
    matchRow = largeDf[(largeDf['Date'] == dateVal)]
  
    # Add the values to the new dataframe if there is a match
    if not matchRow.empty:
      for col in largeDf.columns:
        if col != 'Date':
          newDf.loc[idx, col] = matchRow[col].iloc[0]
  newDf = newDf.dropna()
  return newDf.reset_index(drop = True)



def polyRegression(Xdata, ydata, setDegree):
  """Perform polynomial regression on given X and y data, return the coefficients, intercept and regression score."""

  # Reshape ydata so that it can be aligned with Xdata
  ydata = pd.Series(ydata)
  ydata = ydata.to_frame().values.reshape(-1,1)


  # Create an instance of PolynomialFeatures
  poly = PolynomialFeatures(degree = setDegree, interaction_only = False, include_bias = True)
  polyFeatures = poly.fit_transform(Xdata)

  # Split into test/train data
  xTrain, xTest, yTrain, yTest = train_test_split(polyFeatures, ydata, test_size = 0.25, random_state = 29)

  #2 Train the model with training data
  polyRegModel = LinearRegression()
  fit = polyRegModel.fit(xTrain, yTrain)

  #3 Determine how well out polynomial model fits the data
  score = polyRegModel.score(polyFeatures, ydata)

  return fit.coef_, fit.intercept_, score


from sklearn.linear_model import Lasso
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score


def lassoRegression(X, y, alpha:float):
  """Perform lasso regression on given X and y data, return the coefficients, error and r2 score."""

  # Split into test/train data
  XTrain, XTest, yTrain, yTest = train_test_split(X, y, test_size = 0.25, random_state = 29)

  lassoreg = Lasso(alpha = alpha)

  # Fit the model to the data
  lassoreg.fit(XTrain, yTrain)

  # Calculate the error of regression
  error = np.sqrt(mean_squared_error(yTest, lassoreg.predict(XTest)))

  # Calculate the r2 score of regression
  score = r2_score(yTest, lassoreg.predict(XTest))

  return lassoreg.coef_, error, score



def runAllRegression(infectionDf, measureDf, ycol, measureNum, dateRange):
  # dateRange is a tuple (startDate, endDate), the date should be in the form of '%Y/%M/%D', e.g. ('2020/01/01', '2020/04/30')
  """Integrate all functions and run multiple regressions on worldwide data → write results of regressions into an output spreadsheet"""

  # Find the most implemented measures
  topMeasures = findTopMeasures(measureDf, measureNum)

  # Find countries that have both NPI data and infection data
  countryList1 = allCountries(infectionDf)
  countryList2 = allCountries(measureDf)
  countryList = set(countryList1).intersection(set(countryList2))
  
  polyRegResults = pd.DataFrame()
  lassoRegResults = pd.DataFrame()

  for country in countryList:
    # Process dataframe to create dummy variables
    countryNPI = countryPolicyExtract(measureDf, country, topMeasures)

    dateIndexedNPI, NPIdf = convertDates(countryNPI, 'Date')
    dateFilledDf = fillDateGaps(NPIdf, *dateRange)
    dummyDf = createDummyVariables(dateFilledDf, country, topMeasures)

    # find policies that are actually implemented by this country
    actualNPIs = actualPolicies(df_NPI, country, topMeasures)

    # Create X adn y data used in regression
    Xcols = ['dummy_ ' + npi for npi in actualNPIs]
    Xdf = createXdata(dummyDf, Xcols)
    ydf = createYdata(df_infec, country, ycol)
    ytrend = deseasonalize(createYdata(df_infec, country, ycol), ycol) # deseasonalized data

    # Merge Xdf and ydf to get new X and y data that have the same length
    mergedDf1 = mergeDataframe(Xdf, ydf)
    mergedDf2 = mergeDataframe(Xdf, ytrend)
    
    Xdata1 = mergedDf1[Xcols]
    ydata1 = mergedDf1[ycol]

    Xdata2 = mergedDf2[Xcols]
    ydata2 = mergedDf2[ycol]

    polyResults = {}
    
    # Run polyregression, with degree=1 and degree=2, append results to result dict and dataframe
    for degree in [1, 2]:
      if not Xdata1.empty:
        coef, intercept, score = polyRegression(Xdata1, ydata1, degree)
        if f"polyRegression coefficients(degree={degree})" not in polyResults:
          polyResults[f"polyRegression coefficients(degree={degree})"] = []
        polyResults[f"polyRegression coefficients(degree={degree})"].append(coef)
        if f"polyRegression interce[t(degree={degree})" not in polyResults:
          polyResults[f"polyRegression intercept(degree={degree})"] = []
        polyResults[f"polyRegression intercept(degree={degree})"].append(intercept)
        if f"polyRegression score(degree={degree})" not in polyResults:
          polyResults[f"polyRegression score(degree={degree})"] = []
        polyResults[f"polyRegression score(degree={degree})"].append(score)
      
      if not Xdata2.empty:
        coef, intercept, score = polyRegression(Xdata2, ydata2, degree)
        if f"polyRegression coefficients(degree={degree}, deseasonalized)" not in polyResults:
          polyResults[f"polyRegression coefficients(degree={degree}, deseasonalized)"] = []
        polyResults[f"polyRegression coefficients(degree={degree}, deseasonalized)"].append(coef)
        if f"polyRegression intercept(degree={degree}, deseasonalized)" not in polyResults:
          polyResults[f"polyRegression intercept(degree={degree}, deseasonalized)"] = []
        polyResults[f"polyRegression intercept(degree={degree}, deseasonalized)"].append(intercept)
        if f"polyRegression score(degree={degree}, deseasonalized)" not in polyResults:
          polyResults[f"polyRegression score(degree={degree}, deseasonalized)"] = []
        polyResults[f"polyRegression score(degree={degree}, deseasonalized)"].append(score)

      if f"dummies(degree={degree})" not in polyResults:
        polyResults[f"dummies(degree={degree})"] = []
      polyResults[f"dummies(degree={degree})"].append([Xcols])

      polyresultDf = pd.DataFrame(polyResults, index = [country])

    polyRegResults = pd.concat([polyresultDf, polyRegResults], axis = 0)
    
    lassoResults = {}
    
    # Run lasso regression, append results to result dict and dataframe
    if not Xdata1.empty:
      coef1, error1, score1 = lassoRegression(Xdata1, ydata1, 0.6)
      if f"lassoRegression coefficients" not in lassoResults:
        lassoResults[f"lassoRegression coefficients"] = []
      lassoResults[f"lassoRegression coefficients"].append(coef1)
      if f"lassoRegression error" not in lassoResults:
        lassoResults[f"lassoRegression error"] = []
      lassoResults[f"lassoRegression error"].append(error1)
      if f"lassoRegression score" not in lassoResults:
        lassoResults[f"lassoRegression score"] = []
      lassoResults[f"lassoRegression score"].append(score1)

    if not Xdata2.empty:
      coef2, error2, score2 = lassoRegression(Xdata2, ydata2, 0.6)
      if f"lassoRegression coefficients(deseasonalized)" not in lassoResults:
        lassoResults[f"lassoRegression coefficients(deseasonalized)"] = []
      lassoResults[f"lassoRegression coefficients(deseasonalized)"].append(coef2)
      if f"lassoRegression error(deseasonalized)" not in lassoResults:
        lassoResults[f"lassoRegression error(deseasonalized)"] = []
      lassoResults[f"lassoRegression error(deseasonalized)"].append(error2)
      if f"lassoRegression score(deseasonalized)" not in lassoResults:
        lassoResults[f"lassoRegression score(deseasonalized)"] = []
      lassoResults[f"lassoRegression score(deseasonalized)"].append(score2)

    if "dummies" not in lassoResults:
      lassoResults['dummies'] = []
    lassoResults['dummies'].append([Xcols])

    lassoresultDf = pd.DataFrame(lassoResults, index = [country])
    lassoRegResults = pd.concat([lassoresultDf, lassoRegResults], axis = 0)

  return polyRegResults, lassoRegResults 


def main():

  dateIndex, NPIdf = convertDates(df_infec, 'Date')
  # Draw heatmap based on created intervalDf to show correlation between countries' decisions to implement policies
  topMeasure = findTopMeasures(df_NPI, 10)

  IntervalDf = createIntervalDf(df_NPI, df_infec, topMeasure)
  IntervalDf = IntervalDf.apply(lambda x: x.astype(float))
  makeHeatmap(IntervalDf)


  topMeasureNum = 10  # set this number to n means to find n most implemented NPIs worldwide
  ycol = 'new_cases_per_million'  # set ycol to run regression on chosen time series data in df_infec, can be new_cases, total_cases, deaths, etc

  dateIndex, NPIdf = convertDates(df_infec, 'Date')

  # Analysis and plot infection data of all countries (calculate weekly average of ycol)
  infectionTrend(NPIdf, 'total_cases_per_million')

  # Write regression results to spreadsheet

  polyRegResults, lassoRegResults = runAllRegression(df_infec, df_NPI, ycol, topMeasureNum, ('2020/01/01', '2020/04/30'))

  with pd.ExcelWriter("Regression Results.xlsx") as writer:
    polyRegResults.to_excel(writer, sheet_name = 'polyRegression')
    lassoRegResults.to_excel(writer, sheet_name = 'lassoRegressioin')

  
if __name__ == '__main__':
  main()

# Unit testing
import unittest


class TestFinalProject(unittest.TestCase):

  def test_allCountries(self):
    # Define dataframes taht are used as test inputs
    df1 = pd.DataFrame({'Country': ['USA', 'Canada', 'Mexico']})
    df2 = pd.DataFrame({'Country': ['Japan', 'Japan', 'South Korea', 'South Korea', 'China', 'China', 'China', 'China', 'India']})
    
    # Run the function on test inputs
    output1 = allCountries(df1)
    output2 = allCountries(df2)
    
    '''Type tests'''
    self.assertTrue(isinstance(output1, list), "allCountries should return a list.")
    self.assertTrue(isinstance(output2, list), "allCountries should return a list.")

    '''Length tests'''
    self.assertTrue(len(output1) == 3, "allCountries returns a list with incorrect number of countries.")
    self.assertTrue(len(output2) == 4, "allCountries returns a list with incorrect correct number of countries.")

    '''Value tests'''
    self.assertTrue(output1 == ['USA', 'Canada', 'Mexico'], "allCountries returns a incorrect list")
    self.assertTrue(output2 == ['Japan', 'South Korea', 'China', 'India'], "allCountries returns a incorrect list")


  def test_allMeasures(self):
    # Define dataframes taht are used as test inputs
    df1 = pd.DataFrame({'Measure_L1': ['A', 'B', 'C'], 'Measure_L2': ['B', 'C', 'D'], 'Measure_L3': ['E', 'F', 'F'], 'Measure_L4': ['G', 'H', 'I']})
    
    df2 = pd.DataFrame({'Measure_L1': ['A', 'B'], 'Measure_L2': ['D', 'B'], 'Measure_L3': ['C', ''], 'Measure_L4': ['C', 'C']})
    
    # Run the function on test inputs
    output1 = allMeasures(df1)  
    output2 = allMeasures(df2)
        
    '''Type tests'''
    self.assertTrue(type(output1) == np.ndarray, "allMeasures should return a list")
    self.assertTrue(type(output1) == np.ndarray, "allMeasures should return a list")
    
    '''Length tests'''
    self.assertTrue(len(output1) == 9, "allMeasures returns a list with incorrect number of measures")
    self.assertTrue(len(output2) == 5, "allMeasures returns a list with incorrect number of measures")

    '''Value tests'''
    self.assertTrue(np.setdiff1d(output1, np.array(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'])).size == 0, "allMeasures returns a incorrect list")
    self.assertTrue(np.setdiff1d(output2, np.array(['A', 'B', 'C', 'D', ''])).size == 0, "allMeasures returns a incorrect list")


  def test_findTopMeasures(self):
    # Define dataframe that is used as a test input
    df = pd.DataFrame({
        'Measure_L1': ['School Closure', 'Workplace Closure', 'International Travel Control', 'Gathering Restriction', 'Public Transport Limitations'],
        'Measure_L2': ['School Closure', 'Workplace Closure', 'School Closure', np.nan, np.nan],
        'Measure_L3': ['School Closure', 'Gathering Restriction', 'International Travel Control', 'Public Transport Limitations', np.nan],
        'Measure_L4': [np.nan, 'Workplace Closure', np.nan, 'Workplace Closure', 'Gathering Restriction']
    })
    
    # Run the function on test input
    output = findTopMeasures(df, 3)
    
    '''Type test'''
    self.assertTrue(isinstance(output, list), "findTopMeasures should return a list.")
    
    '''Length test'''
    self.assertTrue(len(output) == 3, "findTopMeasures returns a list with incorrect number of measures.")
    
    '''Value test'''
    self.assertTrue(output == ['School Closure', 'Workplace Closure', 'Gathering Restriction'], "findTopMeasures returns an incorrect list.")


  def test_startDateFinder(self):
    # Define test input dataframes
    data1 = pd.DataFrame({'Date': ['2020/01/01', '2020/01/02', '2020/01/03', '2020/01/04', '2020/01/05'], 
             'Country': ['USA', 'USA', 'USA', 'USA', 'USA'], 
             'new_cases': [0, 0, 1, 2, 4]})
    data2 = pd.DataFrame({'Date': ['2020/01/01', '2020/01/02', '2020/01/03', '2020/01/04', '2020/01/05'], 
             'Country': ['Canada', 'Canada', 'Canada', 'Canada', 'Canada'], 
             'new_cases': [0, 0, 0, 0, 0]})
    
    # Run the function on test inputs
    output1 = startDateFinder(data1, 'USA', 'new_cases')
    output2 = startDateFinder(data2, 'Canada', 'new_cases')
    
    expectedOutput1 = '2020/01/03'
    expectedOutput2 = '2020/1/5'


    """Type tests"""
    self.assertIsInstance(output1, str, "startDateFinder should return a string.")
    self.assertIsInstance(output2, str, "startDateFinder should return a string.")

    """Value tests"""
    self.assertEqual(output1, expectedOutput1, "startDateFinder returns incorrect start date.")
    self.assertEqual(output2, expectedOutput2, "startDateFinder returns incorrect start date.")


  def test_countryPolicyExtract(self):
    # Define a dataframe that is used as test input
    df = pd.DataFrame({
        'Country': ['USA', 'USA', 'USA', 'Canada', 'Canada', 'Canada', 'Canada', 'UK', 'UK'],
        'Date': ['2022/01/01', '2022/02/02', '2022/03/03', '2022/01/04', '2022/02/05', '2022/03/06', '2022/01/03', '2022/01/04', '2022/01/05'],
        'Measure_L1': ['Mask', 'Risk Communication', 'Travel Restriction', 'Quarantine', 'Vaccination', 'Risk Communication',  'Quarantine',  'Quarantine', 'Vaccination'],
        'Measure_L2': ['Mask', 'Vaccination', 'Quarantine', 'Vaccination', 'Risk Communication', 'Travel Restriction', 'Risk Communication', 'Travel Restriction', 'Mask'],
        'Measure_L3': ['Mask', 'Travel Restriction', 'Quarantine', 'Vaccination', 'Risk Communication', 'Vaccination', '-',  'Travel Restriction', 'Mask'],
        'Measure_L4': ['Travel Restriction', 'Quarantine', 'Vaccination', 'Mask', 'Mask', 'Vaccination', 'Risk Communication', 'Hospital', 'Vaccination']
        })
    
    # Run the function on the test inputs
    
    country1 = 'USA'
    policyList1 = ['Quarantine', 'Mask', 'Risk Communication']
    output1 = countryPolicyExtract(df, country1, policyList1)

    country2 = 'Canada'
    policyList2 = ['Vaccination']
    output2 = countryPolicyExtract(df, country2, policyList2)

    country3 = 'UK'
    policyList3 = ['Travel Restriction', 'Vaccination']
    output3 = countryPolicyExtract(df, country3, policyList3)


    '''Type tests'''
    # Test that the function returns a dataframe
    self.assertTrue(type(output1) == pd.core.frame.DataFrame, 'countryPolicyExtract needs to return a dataframe')
    self.assertTrue(type(output1) == pd.core.frame.DataFrame, 'countryPolicyExtract needs to return a dataframe')
    self.assertTrue(type(output1) == pd.core.frame.DataFrame, 'countryPolicyExtract needs to return a dataframe')


    '''Value tests'''
    # Test the function returns the correct dataframe
    expectOutput1 = pd.DataFrame({
        'Date': [datetime.strptime(date, '%Y/%m/%d') for date in ['2022/1/1', '2022/2/2', '2022/2/2']],
        'Measures': ['Mask', 'Risk Communication', 'Quarantine']
    })

    expectOutput2 = pd.DataFrame({
        'Date': [datetime.strptime(date, '%Y/%m/%d') for date in ['2022/1/4']],
        'Measures': ['Vaccination']
    })

    expectOutput3 = pd.DataFrame({
        'Date': [datetime.strptime(date, '%Y/%m/%d') for date in ['2022/1/4', '2022/1/5']],
        'Measures': ['Travel Restriction', 'Vaccination']
    })


    self.assertTrue(output1.equals(expectOutput1), 'countryPolicyExtract returns incorrect dataframe')
    self.assertTrue(output2.equals(expectOutput2), 'countryPolicyExtract returns incorrect dataframe')
    self.assertTrue(output3.equals(expectOutput3), 'countryPolicyExtract returns incorrect dataframe')
 
      
  def test_actualPolicies(self):
    # Define a dataframe that is used as test input
    df = pd.DataFrame({
        'Country': ['USA', 'USA', 'USA', 'Canada', 'Canada', 'Canada', 'Canada', 'UK', 'UK'],
        'Date': ['2022/01/01', '2022/02/02', '2022/03/03', '2022/01/04', '2022/02/05', '2022/03/06', '2022/01/03', '2022/01/04', '2022/01/05'],
        'Measure_L1': ['Mask', 'Risk Communication', 'Travel Restriction', 'Quarantine', 'Vaccination', 'Risk Communication',  'Quarantine',  'Quarantine', 'Vaccination'],
        'Measure_L2': ['Mask', 'Vaccination', 'Quarantine', 'Vaccination', 'Risk Communication', 'Travel Restriction', 'Risk Communication', 'Travel Restriction', 'Mask'],
        'Measure_L3': ['Mask', 'Travel Restriction', 'Quarantine', 'Vaccination', 'Risk Communication', 'Vaccination', '-',  'Travel Restriction', 'Mask'],
        'Measure_L4': ['Travel Restriction', 'Quarantine', 'Vaccination', 'Mask', 'Mask', 'Vaccination', 'Risk Communication', 'Hospital', 'Vaccination'],
        })

    # Define the input arguments for the function
    country1 = 'USA'
    policyList1 = ['Mask', 'Risk Communication', 'Quarantine']
    expectedOutput1 = ['Mask', 'Risk Communication', 'Quarantine']

    country2 = 'Canada'
    policyList2 = ['Vaccination']
    expectedOutput2 = ['Vaccination']

    country3 = 'UK'
    policyList3 = ['Travel Restriction', 'Vaccination', 'Risk Communication']
    expectedOutput3 = ['Travel Restriction', 'Vaccination']

    # Run the function on the test inputs
    output1 = actualPolicies(df, country1, policyList1)
    output2 = actualPolicies(df, country2, policyList2)
    output3 = actualPolicies(df, country3, policyList3)

    """Value tests"""
    self.assertEqual(output1, expectedOutput1, "actualPolicies returned incorrect output for input 1")
    self.assertEqual(output2, expectedOutput2, "actualPolicies returned incorrect output for input 2")
    self.assertEqual(output3, expectedOutput3, "actualPolicies returned incorrect output for input 3")


  def test_intervalCalculator(self):
      NPIdata = pd.DataFrame({
          'Country': ['Canada']*5,
          'Date': ['2020/03/20', '2020/03/21', '2020/03/22', '2020/03/23', '2020/03/24'],
          'Measures': ['School Closure', 'Gathering restriction', 'Business closure', 
                      'Risk communication', 'Travel restriction'],                
      })

      infecdata = pd.DataFrame({
          'Country': ['Canada', 'Canada', 'Canada', 'Canada', 'Canada'],
          'Date': ['2020/01/20', '2020/01/21', '2020/01/22', '2020/01/23', '2020/01/24'],
          'new_cases': [0, 0, 0, 1, 1]
      })

      country = 'Canada'

      """Value test"""
      # Test when country implemented the NPI
      NPI1 = 'School Closure'
      expectedOutput1 = 57

      NPI2 = 'Risk communication'
      expectedOutput2 = 60
      
      # Test when country did not implement the NPI
      NPI3 = 'Border Closure'
      expectedOutput3 = None

      # Run the function on the test inputs
      output1 = intervalCalculator(NPIdata, infecdata, NPI1, country)
      output2 = intervalCalculator(NPIdata, infecdata, NPI2, country)
      output3 = intervalCalculator(NPIdata, infecdata, NPI3, country)

      self.assertEqual(output1, expectedOutput1, "intervalCalculator returned incorrect output for input 1")
      self.assertEqual(output2, expectedOutput2, "intervalCalculator returned incorrect output for input 2")
      self.assertEqual(output3, expectedOutput3, "intervalCalculator returned incorrect output for input 3")


unittest.main(argv=[''], verbosity=2, exit=False)