# -*- coding: utf-8 -*-
"""Simulator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iCaoL-Iej41dwrhY67lz9Bdk8GKPN6Yy
"""

# Junfei Yu  60345054

import numpy as np
import matplotlib.pyplot as plt
import math
from mpl_toolkits import mplot3d


def pickStartPosition(boxDim): # boxDim is an integer greater than 0
  """Generate the particle's starting point (a one-dimensional numpy array containing x, y and z)"""
  x = np.random.randint(-boxDim, boxDim)
  y = np.random.randint(-boxDim, boxDim)
  z = np.random.randint(-boxDim, boxDim)
  startPos = np.array([x,y,z])
  return startPos 


def runOneParticleSimulation(boxDim, numberOfStep):
  """Form numpy array of simulated particle positions after taking several random steps"""
  movementOptions = np.array(([1,-1,0,0,0,0], [0,0,1,-1,0,0], [0,0,0,0,1,-1])) # in order of (+x,-x,+y,-y,+z,-z)
  positions = np.zeros((3, numberOfStep-1))
  startPos = pickStartPosition(boxDim).reshape(3,1)
  positions = np.hstack((startPos,positions))
  for i in range(1, numberOfStep):
    index = np.random.randint(6)
    increment = movementOptions[:, index]
    positions[:, i] = positions[:, i-1] + increment
  return positions

    
def collisionCounter(array1, array2): # both arrays have three rows and same number of columns
  """Check how many times the objects whose paths are described by array1 and array2 ever collide"""
  collisionNum = 0
  counter = 0
  for i in range(np.shape(array1)[1]):
    position1 = array1[:, i]
    position2 = array2[:, i]
    if position1[0] == position2[0] and position1[1] == position2[1] and position1[2] == position2[2]:
      collisionNum += 1
  return collisionNum


def pathCrossCounter(array1, array2):
  """Check how many times the paths traveled by the objects described by array1 and array2 ever crossed"""
  positionSet1 = set()
  positionSet2 = set()
  for i in range(np.shape(array1)[1]):
    position1 = array1[:, i]
    positionSet1.add(tuple(position1)) # Generate a set including all positions that object1 has passed
    position2 = array2[:, i]
    positionSet2.add(tuple(position2)) # Generate a set including all positions that object2 has passed
  intersection = positionSet1.intersection(positionSet2)
  crossNum = len(intersection)
  return crossNum


def distanceBetweenPoints(xyz1, xyz2):
  """Calculate the distance between points contained in xyz1 and xyz2"""
  x1, y1, z1 = xyz1
  x2, y2, z2 = xyz2
  square1 = (x2 - x1)**2
  square2 = (y2 - y1)**2
  square3 = (z2 - z1)**2
  distance = math.sqrt(square1 + square2 + square3)
  return distance


def allDistancesFinder(array1, array2):
  """Create a numpy array of distances between the points in array1 and array2"""
  distanceList = []
  for i in range(np.shape(array1)[1]):
    position1 = array1[:, i]
    position2 = array2[:, i]
    distance = distanceBetweenPoints(position1, position2)
    distanceList.append(distance)
  distanceArray = np.array(distanceList)
  return distanceArray


def simulationStats(array1, array2):
  """Calculate five pieces of information for the two particles represented by array1 and array2"""
 
  firstPoint1 = array1[:, 0]
  finalPoint1 = array1[:, np.shape(array1)[1]-1]
  displacement1 = distanceBetweenPoints(firstPoint1, finalPoint1) #1 Displacement for particle 1

  firstPoint2 = array2[:, 0]
  finalPoint2 = array2[:, np.shape(array2)[1]-1]
  displacement2 = distanceBetweenPoints(firstPoint2, finalPoint2) #2 Displacement for particle 2

  #3 Average distance between particle 1 and particle 2 throughtout the simulation
  distanceList = []
  for i in range(np.shape(array1)[1]):
    distance12 = distanceBetweenPoints(array1[:, i], array2[:, i])
    distanceList.append(distance12)
  averageDistance = sum(distanceList)/len(distanceList)

  collisionNum = collisionCounter(array1, array2) #4 Number of collisions
  crossNum = pathCrossCounter(array1, array2) #5 Number of path crosses

  informationArray = np.array([displacement1, displacement2, averageDistance, collisionNum, crossNum])

  return informationArray


def runSummarizeManySimulations(boxDim, numberOfSims, numberOfSteps):
  """Integrate information from each simulation into one array"""
  array1 = runOneParticleSimulation(boxDim, numberOfSteps)
  array2 = runOneParticleSimulation(boxDim, numberOfSteps)
  statsOfSims = simulationStats(array1, array2)
  for i in range(1, numberOfSims):
    array1 = runOneParticleSimulation(boxDim, numberOfSteps)
    array2 = runOneParticleSimulation(boxDim, numberOfSteps)
    statsOfSims = np.vstack((statsOfSims,simulationStats(array1, array2)))

  fig = plt.figure()
  ax = plt.axes(projection='3d')
  ax.plot3D(array1[0], array1[1], array1[2], 'blue')
  ax.plot3D(array2[0], array2[1], array2[2], 'red')
  ax.set_xlabel('x-axis')
  ax.set_ylabel('y-axis')
  ax.set_zlabel('z-axis')
  plt.show()

  return statsOfSims


def statSummarizer(array):
  """Caluculate mean and standard deviation of stats and integrate the numbers into one array"""
  means = np.mean(array, axis=0)
  if isinstance(means, np.ndarray):
    meansArray = means.reshape(len(means), 1)
  else:
    meansArray = array.reshape(len(array), 1)
  stds = np.std(array, axis=0)
  if isinstance(stds, np.ndarray):
    stdsArray = stds.reshape(len(stds), 1)
  else:
    stdsArray = np.zeros((len(array),1))
  statArray = np.hstack((meansArray, stdsArray))
  print(statArray)
  return statArray


def main():
  boxDim = 10
  numberOfSims = 1
  numberOfSteps = 10000
  statsOfSims = runSummarizeManySimulations(boxDim, numberOfSims, numberOfSteps)
  print(statsOfSims)
  statSummarizer(statsOfSims)
  return


def test():
  print(pickStartPosition(5))

  testArray1 = np.array([[0,0,0,0],[0,0,0,0],[0,1,2,3]])
  testArray2 = np.array([[0,0,0,0],[0,0,0,0],[0,1,2,3]])
  testArray3 = np.array([[0,0,0,0],[0,0,0,0],[1,0,0,0]])
  testArray4 = np.array([[0,0,0,0],[0,0,0,0],[0,1,2,3]])
  testArray5 = np.array([[0,0,0,0],[0,0,0,0],[0,1,2,3]])
  testArray6 = np.array([[0,0,0,0],[0,0,0,0],[3,2,1,0]])

  print(collisionCounter(testArray1, testArray2))
  print(collisionCounter(testArray3, testArray4))
  print(collisionCounter(testArray5, testArray6))

  print(pathCrossCounter(testArray1, testArray2))
  print(pathCrossCounter(testArray3, testArray4))
  print(pathCrossCounter(testArray5, testArray6))

  point1 = np.array([0,0,0])
  point2 = np.array([0,5,0])
  point3 = np.array([0,0,5])
  point4 = np.array([5,0,0])
  print(distanceBetweenPoints(point1,point2))
  print(distanceBetweenPoints(point1,point4))
  print(distanceBetweenPoints(point2,point3))
  print(distanceBetweenPoints(point2,point4))


# Don't change this!
if __name__ == "__main__":
  main()