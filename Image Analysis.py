# -*- coding: utf-8 -*-
"""Images.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MniliW8iXQJntJrQiD-o79rwKpmrg5zn
"""

# Junfei Yu 60345054
import cv2
import pandas as pd
import numpy as np
#from google.colab.patches import cv2_imshow ###COMMENT THIS LINE OUT PRIOR TO SUBMITING TO GRADESCOPE

#from google.colab import drive ###COMMENT THIS LINE OUT PRIOR TO SUBMITING TO GRADESCOPE
#drive.mount('/content/drive') ###COMMENT THIS LINE OUT PRIOR TO SUBMITING TO GRADESCOPE


def contourFinder(fileName, lowerBound, blur = False):
  """Read in fileName as a grayscale image, find contours of the thresholded image and draw contours of the original image"""
  image = cv2.imread(fileName, cv2.IMREAD_GRAYSCALE)

  # apply a gaussian blur to the image to reduce background noise if desired
  if blur:
    image = cv2.GaussianBlur(image, (5, 5), cv2.BORDER_DEFAULT)

  ret, thresh = cv2.threshold(image, lowerBound, 255, cv2.THRESH_BINARY)

  contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

  cnt = cv2.drawContours(image, contours, -1, (255, 255, 255), 3)
  #cv2_imshow(cnt)

  return contours


def areaFinder(contours):
  """Return the area bounded by the given contours of one object"""
  area = cv2.contourArea(contours)
  return area


def maxAreaContourFinder(contours):
  """Read in the contours and returns the contours containing the largest area"""
  maxArea = 0
  maxIndex = -1

  for i in range(len(contours)):
    area_i = cv2.contourArea(contours[i])
    if area_i > maxArea:
      maxArea = area_i
      maxIndex = i
  maxContour = contours[maxIndex]

  return maxContour


def centroidFinder(contours):
  """Return the centroid of the object bounded by the given contours them as a tuple"""
  M = cv2.moments(contours)

  if M["m00"] != 0:
    cX = int(M["m10"] / M["m00"])
    cY = int(M["m01"] / M["m00"])

  return (cX, cY)
  

def brightnessFinder(fileName,contours):
  """Find the average brightness of the region in the image bounded by the contours"""
  image = cv2.imread(fileName)
  kernel = np.ones((9,9),np.uint8)
  ret, thresh = cv2.threshold(image, 30, 255, cv2.THRESH_BINARY)
  frameDraw = np.zeros(thresh.shape, np.uint8)  # create an array or black canvas on which to draw contours
  cont = cv2.fillPoly(frameDraw, [contours], 255) # on frameDraw, draw each contour and fill in white

  locs = np.where(cont == 255)  # pull out pixel values where the drawn image is white
  pixels = image[locs]  # look up the values of the original fabric image at these locations
  brightness = np.mean(pixels)  # take the mean of theses values and add to out list

  return brightness


def velocityCalculator(centroid1,centroid2):
  """Calculate and return the velocity based on two given centroid positions ten minutes apart"""
  distance = pow((centroid2[0] - centroid1[0])**2 + (centroid2[1] - centroid1[1])**2, 0.5)
  velocity = distance/10
  return velocity


def relChangeFinder(val1, val2):
  """Calculate and return the relative change based on two numbers corresponding to 0min and 10min"""
  if val1 == 0:
    relChange = 1
  else:
    relChange = (val2 - val1) / val1
  return relChange


def oneTrial(trialName, threshold):
  """Return a list containing [trial name, velocity, area change, brightness change]"""
  # read and find contours corresponding to the largest object for both the 0min and 10 min

  fileName_0 = trialName + '_0min.tif'
  fileName_10 = trialName + '_10min.tif'

  contours_0 = contourFinder(fileName_0, threshold, blur = True)
  maxContour_0 = maxAreaContourFinder(contours_0)

  contours_10 = contourFinder(fileName_10, threshold, blur = True)
  maxContour_10 = maxAreaContourFinder(contours_10)

  # calculate the centroid position, area, and brightness value at each timepoint
  # at 0min
  centroid_0 = centroidFinder(maxContour_0)
  centroid_10 = centroidFinder(maxContour_10)

  area_0 = areaFinder(maxContour_0)
  area_10 = areaFinder(maxContour_10)

  bright_0 = brightnessFinder(fileName_0, maxContour_0)
  bright_10 = brightnessFinder(fileName_10, maxContour_10)

  # calculate the velocity, relative area change, and relative brightness change
  velocity = velocityCalculator(centroid_0,centroid_10)
  relAreaChange = relChangeFinder(area_0, area_10)
  relBrightChange = relChangeFinder(bright_0, bright_10)
  
  return [trialName, velocity, relAreaChange, relBrightChange]


def allTrials():
  """Run oneTrial for each trial (types 1 and 2, cells 1-5 for each), collect their outputs in one nested list, and return that list"""
  outputs = []
  for cellType in range(1,3):
    for cellNum in range(1,6):
      trialName = 'type' + str(cellType) + '_cell' + str(cellNum)
      print(trialName)
      threshold = 30
      output = oneTrial(trialName, threshold)
      outputs.append(output)
  return outputs


def dataWriter(nestedList):
  """Write the nested list to a spreadsheet"""
  df = pd.DataFrame(nestedList, columns = ['Trial Name', 'Velocity', 'Area Change', 'Brightness Change'])
  with pd.ExcelWriter('statDataframe.xlsx') as writer:
    df.to_excel(writer, sheet_name = 'Sheet1', index = False)


def main():
  dataList = allTrials()
  dataWriter(dataList)

if __name__ == "__main__":
  main()

# Unit testing
import unittest
import math

class TestImages(unittest.TestCase):

  def test_velocityCalculator(self):
    # define some centroids that are used as test inputs
    input1 = ((0,0), (math.sqrt(50), math.sqrt(50)))
    input2 = ((0,0), (3,4))
    input3 = ((0,0), (6,8))

    # run the function on test inputs
    output1 = velocityCalculator(*input1)
    output2 = velocityCalculator(*input2)
    output3 = velocityCalculator(*input3)
    
    '''Type tests'''
    # testing that the function returns a number
    self.assertTrue(type(output1) == 'float' or 'int', "velocityCalculator needs to return a number")
    self.assertTrue(type(output2) == 'float' or 'int', "velocityCalculator needs to return a number")
    self.assertTrue(type(output3) == 'float' or 'int', "velocityCalculator needs to return a number")

    '''Value tests'''
    # testing that the function returns the correct value
    self.assertTrue(output1 == 1, "velocityCalculator returns incorrect value")
    self.assertTrue(output2 == 0.5, "velocityCalculator returns incorrect value")
    self.assertTrue(output3 == 1, "velocityCalculator returns incorrect value")


  def test_relChangeFinder(self):
    # define some centroids that are used as test inputs
    input1 = (0, 1)
    input2 = (5, 6)
    input3 = (-1.2, 3.6)

    # run the function on test inputs
    output1 = relChangeFinder(*input1)
    output2 = relChangeFinder(*input2)
    output3 = relChangeFinder(*input3)
    
    '''Type tests'''
    # testing that the function returns a number
    self.assertTrue(type(output1) == 'float' or 'int', "relChangeFinder needs to return a number")
    self.assertTrue(type(output2) == 'float' or 'int', "relChangeFinder needs to return a number")
    self.assertTrue(type(output3) == 'float' or 'int', "relChangeFinder needs to return a number")

    '''Value tests'''
    # testing that the function returns the correct value
    self.assertTrue(output1 == 1, "relChangeFinder returns incorrect value")
    self.assertTrue(output2 == 0.2, "relChangeFinder returns incorrect value")
    self.assertTrue(output3 == -4, "relChangeFinder returns incorrect value")


unittest.main(argv=[''], verbosity=2, exit=False)