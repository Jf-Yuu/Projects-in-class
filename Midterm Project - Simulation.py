# -*- coding: utf-8 -*-
"""Midterm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1my_cig8BRtqn4r4tnmby8vSPyJLIyWN5
"""

# Junfei Yu  60345054

import math
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d


WindDirection = {'N': [1,0,0], 'E': [0,1,0], 'S': [-1,0,0], 'W': [0,-1,0]}


def environmentParameter(generalWindDirection, theta, windSpeed, atmosphericStability): 
  # generalWindDirection can be any of N, E, S and W based on main wind direction during that time
  # theta is the clockwise angle between actual and main wind direction, measured by degrees
  # atmosphericStability is a float between 0 and 1, which measures the level of deviation of particle moveming direction from actual wind direction, deviation is smaller when atmosphericStability is larger
  """Transform and store already-known environment parameters into data types applicable to the program"""
  
  # Generate the direction that particle will traval based on wind direction
  sinTheta = math.sin(math.radians(theta))
  cosTheta = math.sqrt(1 - sinTheta**2)
  if generalWindDirection == 'N':
    direction = np.array([sinTheta, cosTheta, 0])
  elif generalWindDirection == 'E':
    direction = np.array([cosTheta, -sinTheta, 0])
  elif generalWindDirection == 'S':
    direction = np.array([-sinTheta, -cosTheta, 0])
  else:
    direction = np.array([-cosTheta, sinTheta, 0])
  
  # Generate deviation numpy array based on atmosperic stability
  xDev = (1 - atmosphericStability) * cosTheta
  yDev = (1 - atmosphericStability) * sinTheta
  deviation = np.array([xDev, yDev, 0])

  # Generate step size based on windSpeed
  strideLen = windSpeed # m/s

  return (direction, deviation, strideLen)



def distanceBetweenPoints(xyz1, xyz2):
  """Calculate the distance between points contained in xyz1 and xyz2"""
  x1, y1, z1 = xyz1
  x2, y2, z2 = xyz2
  square1 = (x2 - x1)**2
  square2 = (y2 - y1)**2
  square3 = (z2 - z1)**2
  distance = math.sqrt(square1 + square2 + square3)
  return distance



def boundaryReached(startPos, xyz, boundary, strideLen):
  """Decide whether a particle has travelled close to the boundary"""
  distance = distanceBetweenPoints(xyz, startPos)
  if distance < boundary - strideLen:
    return True
  else:
    return False



def runOneParticleSimulation(startPos, numberOfSteps, direction, deviation, strideLen, boundary):
  """Form numpy array of simulated particle positions after taking several random steps
    Particles move within a specially confined region decided by value of boundary."""
  positions = np.zeros((3, numberOfSteps - 1))
  startPos = startPos.reshape(3,1)
  positions = np.hstack((startPos,positions))

  # Assume particles also make go through random height variation
  heightMovement = np.array(([0,0], [0,0], [1,-1]))
  for i in range(1, numberOfSteps):
    index = np.random.randint(0,2)
    heightIncrement = heightMovement[:, index] * np.random.random() / 100
    increment = (direction + deviation * np.random.rand(1,3)) * strideLen
    if boundaryReached(startPos, positions[:, i-1], boundary, strideLen):
      positions[:, i] = positions[:, i-1] + increment + heightIncrement
    else:
      positions[:, i] = positions[:, i-1]
  return positions



def particalPaths(numberOfParticles, startPos, numberOfSteps, direction, deviation, strideLen, boundary):
  """Form numpy array containg all the simulated path of all particles"""
  pathsArray = runOneParticleSimulation(startPos, numberOfSteps, direction, deviation, strideLen, boundary)
  for i in range(1, numberOfParticles):
    arrayi = runOneParticleSimulation(startPos, numberOfSteps, direction, deviation, strideLen, boundary)
    pathsArray = np.vstack((pathsArray,arrayi))
  return pathsArray # rowNum = number of particles * 3; colNum = number of steps



def simulationDistanceStat(array):
  """Calculate information related to displacements of all particles and average distance between particles"""
  #1 Calculate displacement for particle i
  displacementList = []
  for i in range(len(array)//3):
    arrayi = array[3*i:3*(i+1),]
    firstPoint = arrayi[:, 0]
    finalPoint = arrayi[:, np.shape(arrayi)[1] - 1]
    displacement = distanceBetweenPoints(firstPoint, finalPoint)
    displacementList.append(displacement)

  #2 Average distance between any two particle m and particle n throughtout the simulation
  distanceList = []
  for m in range(len(array)//3):
    arraym = array[m:m+3, ]
    for n in range(m, len(array)//3):
      for k in range(1, np.shape(array)[1]):
        arrayn = array[n:n+3, ]
        distance_mn = distanceBetweenPoints(arraym[:, k], arrayn[:, k])
      distanceList.append(distance_mn)
  averageDistance = sum(distanceList)/len(distanceList)

  displacementArray = np.array(displacementList)

  return displacementArray, averageDistance



def getPositionList(array):
  """Return the list containing all the positions that particles have passed by"""
  positionList = []
  for i in range(len(array)//3):
    arrayi = array[3*i:3*(i+1), ]
    for k in range(np.shape(array)[1]):
      positioni = arrayi[:, k]
      positionList.append(tuple(positioni)) # Generate a list including all positions that object1 has passed
  return positionList



def polutionLevelDecide(array, numberOfParticles, location):
  """Check whether a certain location that user is concerned about has a harmful polution level,
    the level is decided by how many times the paths of particles ever passed through the location"""
  positionList = getPositionList(array)
  passCounter = positionList.count(location)
  if passCounter < 1:
    polutionLevel = 'Low'
  elif passCounter <= 3:
    polutionLevel = 'Polluted'
  else:
    polutionLevel = 'Harmful'
  return polutionLevel



def highlyPollutedLocation(array, startPos, numberOfParticles, boundary):
  """Find all the locations within the boundary that has been highly polluted (harmful polution level)"""
  highlyPollutedLoc = []
  positionList = getPositionList(array)
  positionSet = set(positionList)
  for pos in positionSet:
    if distanceBetweenPoints(pos, startPos) < boundary * 3/4:
      passCounter = positionList.count(pos)
      if passCounter > 3:
        highlyPollutedLoc.append(pos)
  return highlyPollutedLoc



def randomcolor(): # source: https://blog.csdn.net/onlyforbest/article/details/108025942
  """Generate random color codes to be later used to draw plots"""
  colorArr = ['1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']
  color = ""
  for i in range(6):
    color += colorArr[np.random.randint(0,14)]
  return "#"+color



def plotGenerator(array, startPos, numberOfParticles, boundary):
  """Generate plot based on existing information: paths of particles and highly polluted locations"""
  fig = plt.figure()
  ax = plt.axes(projection='3d')

  # draw paths
  for i in range(numberOfParticles):
    arrayi = array[3*i:3*(i+1), ]
    ax.plot3D(arrayi[0], arrayi[1], arrayi[2], randomcolor())

  # draw scatter points showing polluted locations
  highlyPollutedLoc = highlyPollutedLocation(array, startPos, numberOfParticles, boundary)
  for j in range(len(highlyPollutedLoc)):
    x, y, z = highlyPollutedLoc[j]
    ax.scatter(x, y, z, color = 'black')

  ax.set_xlabel('West-East')
  ax.set_ylabel('Sorth-Nouth')
  ax.set_zlabel('Height')
  ax.set_title('Gas particles transmission from source of pollution')


def main():

  generalWindDirection = 'N'  # The general wind direction N/E/S/W''
  theta = 30  # 0 < theta < 90
  windSpeed = 8  # an integer showing wind speed (m/s)
  # a float between 0 and 1 showing stability, the degree of dispersion is supposed to be higher when atmosphericStability is smaller
  atmosphericStability = 0.6 

  startPos = np.array([0,0,0])
  numberOfSteps = 1000
  numberOfParticles = 100
  boundary = 1000

  # Get environment parameters that decides how particles moves
  direction, deviation, strideLen = environmentParameter(generalWindDirection, theta, windSpeed, atmosphericStability)
  
  array = particalPaths(numberOfParticles, startPos, numberOfSteps, direction, deviation, strideLen, boundary)

  print('Polluted Locations: ', highlyPollutedLocation(array, startPos, numberOfParticles, boundary))

  # print statistics about displacement of particles and average distance
  displacementArray, averageDistance = simulationDistanceStat(array)
  print('Simulation statistic', 'Displacement Array', displacementArray, 'Average Distance', averageDistance, sep = '\n')

  location = (1,1,1)
  pollutionLevel = polutionLevelDecide(array, numberOfParticles, location)
  print('Pollution level at position', location, 'is', pollutionLevel, end = '\n')

  plotGenerator(array, startPos, numberOfParticles, boundary)


if __name__ == "__main__":
  main()